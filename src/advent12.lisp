(require 'str)
(require 'alexandria)
(use-package 'alexandria)

(defparameter *input-file* #p"~/Projects/AoC2021/input/input12.txt")

(defun aoc12-load-input ()
  (loop for line in (uiop:read-file-lines *input-file*)
	collect (str:split "-" line)))

(defun add-path-to-hash (path paths-hash)
  (let ((p path))
    (when (or (string-equal (second p) "start")
	      (string-equal (first p) "end"))
      (rotatef (first p) (second p)))
    (push (second p) (gethash (first p) paths-hash))
    (when (and (not (string-equal (first p) "start"))
	       (not (string-equal (second p) "end")))
      (push (first p) (gethash (second p) paths-hash)))))

(defun build-path-hash (input)
  (let ((paths (make-hash-table :test 'equal)))
    (loop for path in input do
      (add-path-to-hash path paths))
    paths))

(defun upcase-p (s)
  (loop for c across s do
    (when (lower-case-p c) (return-from upcase-p nil)))
  t)

(defun lowercase-p (s)
  (loop for c across s do
    (when (upper-case-p c) (return-from lowercase-p nil)))
  t)

(defun visited-twice (visited)
  (let ((visits (make-hash-table :test 'equal)))
    (loop for c in visited do
      (when (and (lowercase-p c)
		 (not (string-equal c "start"))
		 (not (string-equal c "end")))
	(if (gethash c visits)
	    (incf (gethash c visits))
	    (setf (gethash c visits) 1))))
    (> (length (remove-if-not #'(lambda (x) (> x 1))
			      (hash-table-values visits)))
       0)))

(defun follow-path (node paths visited)
  (let* ((path (gethash node paths))
	 (tree nil))
    (when (or (not path) (string-equal node "end"))
      (return-from follow-path (list visited)))
    (dolist (p path)
      (let ((new-visited (cons p visited)))
	(if (upcase-p p)
	    (if (not tree)
		(setf tree (follow-path p paths new-visited))
		(setf tree (append (follow-path p paths new-visited) tree)))
	    (when (not (member p visited :test 'equal))
	      (if (not tree)
		  (setf tree (follow-path p paths new-visited))
		  (setf tree (append (follow-path p paths new-visited) tree)))))))
    tree))

(defun follow-path-twice (node paths visited)
  (let* ((path (gethash node paths))
	 (tree nil))
    (when (or (not path) (string-equal node "end"))
      (return-from follow-path-twice (list visited)))
    (dolist (p path)
      (let ((new-visited (cons p visited)))
	(if (upcase-p p)
	    (if (not tree)
		(setf tree (follow-path-twice p paths new-visited))
		(setf tree (append (follow-path-twice p paths new-visited) tree)))
	    (when (or (not (visited-twice visited))
		      (not (member p visited :test 'equal)))
	      (if (not tree)
		  (setf tree (follow-path-twice p paths new-visited))
		  (setf tree (append (follow-path-twice p paths new-visited) tree)))))))
    tree))


(defun aoc1201 ()
  (let* ((input (aoc12-load-input))
	 (paths (build-path-hash input)))
    (follow-path "start" paths (list "start"))))

(defun aoc1202 ()
  (let* ((input (aoc12-load-input))
	 (paths (build-path-hash input)))
    (follow-path-twice "start" paths (list "start"))))
